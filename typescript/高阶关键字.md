# is

类型保护，声明参数类型。

类型保护的作用域仅仅在 if 后的块级作用域中生效

```typescript
function isString(test: any): test is string{
  return typeof test === "string";
}

function example(foo: any){
  if(isString(foo)){
      console.log(foo.toExponential(2));
  }
  // 编译不会出错，但是运行时出错
  console.log(foo.toExponential(2));
}
example("hello world");
```



```typescript
function isString(test: any): boolean{
  return typeof test === "string";
}
function example(foo: any){
  if(isString(foo)){
      console.log("it is a string" + foo);
      console.log(foo.length); // string function
      // foo 为 any，编译正常。但是运行时会出错，因为 foo 是 string 不存在toExponential方法
      console.log(foo.toExponential(2));
  }
}
example("hello world");
```





```typescript
const isString = (val: any): val is string => typeof val === 'string'
// 当isString返回值为true的时候, 参数val就是string类型.
```



## record

```typescript
/** 源码：
 * Construct a type with a set of properties K of type T
 */
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
```

将一个类型的所有属性值都映射到另一个类型上并创造一个新的类型.

```typescript
// 用法
type petsGroup = 'dog' | 'cat' | 'fish';
interface IPetInfo {
    name:string,
    age:number,
}

type IPets = Record<petsGroup, IPetInfo>;

const animalsInfo:IPets = {
    dog:{
        name:'dogName',
        age:2
    },
    cat:{
        name:'catName',
        age:3
    },
    fish:{
        name:'fishName',
        age:5
    }
}

```

## Partial

```typescript
/**
 * Make all properties in T optional
 */
type Partial<T> = {
    [P in keyof T]?: T[P];
};
```

使所有属性变为可选属性。

```
interface IUser {
  name: string
  age: number
  department: string
}
type optional = Partial<IUser>

// optional的结果如下

type optional = {
    name?: string | undefined;
    age?: number | undefined;
    department?: string | undefined;
}
```



## keyof

索引类型查询操作符，我们可以将 keyof 作用于泛型 T 上来获取泛型 T 上的所有 public 属性名构成的 联合类型

```typescript
type unionKey = keyof IUser

// unionKey 结果如下，其获得了接口类型 IUser 中的所有属性名组成的联合类型
type unionKey = "name" | "age" | "department"
```

## in

我们需要遍历 `IUser` ，这时候 `映射类型`就可以用上了，其语法为 `[P in Keys]`

- P：类型变量，依次绑定到每个属性上，对应每个属性名的类型
- Keys：字符串字面量构成的联合类型，表示一组属性名（的类型），可以联想到上文 `keyof` 的作用

## Omit

`Omit<T, K>` 类型让我们可以从另一个对象类型中剔除某些属性，并创建一个新的对象类型：

```typescript
type User = {

id: string;

name: string;

email: string;

};

type UserWithoutEmail = Omit<User, "email">;

// 等价于:

type UserWithoutEmail = {

id: string;

name: string;

};
```

源码

```typescript
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```

[详细](https://segmentfault.com/a/1190000022429482)







[TypeScript中的高级类型工具类型及关键字](https://juejin.cn/post/6900712964299423758#heading-9)
