# classes （类）
1. 类属性需要先进行声明。
2. 成员有三种访问修饰符：
    - private:私有，只能在声明它的类内部可以访问。
    - protected:受保护的，在自身、子类可以访问。
    - public:默认值, 可以在自身、子类和实例上访问。
3. 只读修饰符`readonly`，属性只能在初始化时赋值。
```js
//TS
class Animal {
    private name:string='Animal' // 或#name
    constructor(name:string) {
        this.name = name 
    }
    private move(){
        console.log(`${this.name}moving`)
    }
    // 或者利用#来声明私有变量
    // #name :string
    // constructor(name:string) {
    //     this.#name = name
    // }
}
class Person extends Animal {
    protected  age:number; 
    public readonly country:string='china' //只能在初始化时声明
    constructor(name:string, age:number,country:string,) {
        super(name)
        this.age = age
        this.country=country
    }
    //  参数属性，可以直接在参数设置作为属性
    getName() {
        console.log(`${this.name}moving`) //Error: 'name' is private;
    }
    walk(){
        console.log(``)
    }
}

let li = new Person('xiwang', 23,'japan')
li.walk()
li.country ='french' //Cannot assign to 'country' because it is a read-only property.(2540)
```
```js
//es6
class Animal {
    constructor(name) {
        this.name = name
    }
    move() {
        console.log('animal moving')
    }
}
class Person extends Animal {
    constructor(name, age) {
        super(name)
        this.age = age
    }
    move() {
        console.log(`${this.name}moving`)
    }
}

let li = new Person('xiwang', 23)
li.move()
```

1. 参数属性
  通过在构造函数的参数上增加修饰符，可以直接将参数作为类的属性
```js
class Animal{
    constructor(public name:string ){
    }
    /* 等价于
    public name:string
     constructor(name:string){
        this.name = name   
    }
    */
    move(){
        console.log(`${this.name} moving`)
    }
}

let person = new Animal('person')
person.move() //person moving 
```
5. 存取器
    通过`get`和`set`方法，一般用于拦截对类私有成员的访问和赋值。
    ```
    class Animal{
    constructor(private _name:string ){
    }
    get name():string{
        return this._name
    }
    set name(name:string){
        this._name=name
    }
    }

    let person = new Animal('person')
    person.name='lixiwang'
    console.log(person.name) // lixiwang
    ```
6. 静态属性
    使属性存在于类本身，可以通过类访问该属性。
    ```ts
    class Animal{
        static className='Animal'
        constructor(private _name:string ){
            console.log(this.className) // error,Property 'className' is a static member of type 'Animal'(2576)
            console.log(Animal.className)
        }
        get name():string{
            return this._name
        }
        set name(name:string){
            this._name=name
        }
    }
    let person = new Animal('person')
    console.log(Animal.className) // Animal 
    ```
7. 抽象类
   用于定义类的成员，和接口的概念一样。
   ```js
    abstract class Animal{
        abstract walk():void; // 抽象方法必须有abstract 
        abstract name:string
        public move():void{
            console.log(`${this.name} move`)
        }
    }
    class animal extends Animal{
        constructor(public name:string){
            super() //派生类的构造器必须有super()
        }
        walk(){
            console.log('walk')
        }
    }
    let person = new animal('person')
    person.move()
    ```